# 깊은 복사와 얕은 복사

r1 = [1, 2, 3]
r2 = [1, 2, 3]
print(r1 is r2)
print(r1 == r2)
"""
1.
is와 == 연산에 대해 알아보고 가겠다.
리스트 [1, 2, 3]은 변수 r1을 참조한다. 또 다른 리스트 [1, 2, 3]은 r2를 참조한다.
이것을 is와 == 연산을 통해 실행시켜보면 boolean 값은 각각 다르게 나올 것이다.
정리하자면, is는 참조하는 객체가 같은가? 의 질문이고 ==은 객체의 내용이 같은가? 의 질문이다.
"""

r1 = [1, 2, 3]
r2 = r1
print(r1 is r2)
print(r1 == r2)
"""
2.
위의 코드 내용과 별반 다를 것이 없지만 기존에는 각자의 객체가 다른 변수를 참조하게 했다면 이번에는 r2가 r1 객체를 참조하는 느낌이다.
즉, 위에서 r1의 레퍼런스 카운트는 1, r2의 레퍼런스 카운트는 1이었지만 아래에서는 r1의 레퍼런스 카운트가 2가 된다.
따라서 r1과 r2가 모두 동일한 리스트 [1, 2, 3]를 참조받게 되므로 is 연산자가 True가 되는 것이다.
"""

r1 = ['CSD', ('man', 'KOREA'), [182, 84]]
r2 = list(r1)
print(r1)
print(r2)
print(id(r1))
print(id(r2))
print(r1 is r2)
print(r1[0] is r2[0])
print(r1[1] is r2[1])
print(r1[2] is r2[2])

r1[2][1] -= 1
print(r1)
print(r2)
"""
3.
r1이라는 변수에 여러가지 타입의 객체를 참조시켰다. r2는 r1 전체를 참조하는 것이 아니라 리스트만 참조시킨 상황이다.
불변의 객체인 문자열, 튜플이 있고 가변의 객체인 리스트가 존재한다. 따라서 r1과 r2는 생김새는 같지만 다른 객체가 참조되어있다.
위 예제에서 파이썬의 복사는 리스트까지만 복사가 되고 내부의 객체를 참조하는 식으로 진행된다.
즉, r1[0] 객체는 문자열 'CSD'를 참조하는데 새로 복사된 r2[0] 객체는 r1[0] 객체를 참조한다는 의미이다.
레퍼런스 카운트로 따지면 r1[0]의 레퍼런스 카운트는 1이지만 r2가 r1를 참조하면서 r1[0]의 레퍼런스 카운트는 2가 되는 것이다.

문자열이나 튜플과 같은 immutable한 객체는 수정을 할 수 없는 객체이므로 복사를 하더라도 참조만 할 수 있다.
하지만, 리스트는 mutable한 객체이므로 수정이 가능한데 동일한 객체를 참조하므로 값을 변경하면 둘 다 변경이 된다.
"""

c1 = (1, 2, 3)
c2 = 'Python'
c3 = [1, 2, 3]
d1 = tuple(c1)
d2 = str(c2)
d3 = list(c3)
print(c1 is d1)
print(c2 is d2)
print(c3 is d3)
"""
4.
파이썬에서의 복사 개념을 다시 정리하면 다음과 같다.
immutable한 객체는 불변의 속성이 있기 때문에 파이썬에서는 동일한 객체를 참조시키고 있었다.
하지만 mutable한 객체는 가변의 속성이 있기 때문에 파이썬에서는 다른 객체를 참조시키도록 만들고 있었던 것이다.
즉, 메모리의 효율적인 사용을 위해 immutable하면 레퍼런스 카운트를 1 늘리면서 동일한 객체를 참조시키고 mutable하면 다른 객체로 인식시켜 레퍼런스 카운트를 각자 1 늘린 것이다.
"""

import copy
r1 = ['CSD', ('man', 'KOREA'), [182, 84]]
r2 = copy.deepcopy(r1)
r2[2][0] += 1
print(r1)
print(r2)
"""
5.
참조하는 것만 복사시키는 것을 얕은 복사, 전체를 복사시키는 것을 깊은 복사라고 한다.
copy 모듈을 사용해 deepcopy를 하면 immutable한 객체는 한 객체만 이용하고 mutable한 객체는 따로 이용한다.
메모리 상으로 이득이 되는 것이다.
"""