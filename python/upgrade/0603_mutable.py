# 수정 가능한 객체와 수정 불가능한 객체

"""
1.
파이썬에서 우리가 주로 사용하던 객체 중에 수정 가능한 것과 가능하지 않은 것이 있었다.
수정이 가능했던 객체는 대표적으로 리스트, 딕셔너리가 있고 수정이 불가능했던 객체는 문자열과 튜플이 있다.
이제부터 수정이 가능한 객체는 mutable 객체, 수정이 불가능한 객체는 immutable 객체라고 하겠다.
"""

r = [1, 2]
print(id(r))
r += [3, 4]
print(id(r))
"""
2.
위의 설명을 조금 예시를 들어보겠다. r이라는 변수에 리스트 [1, 2]를 참조시키고 id를 확인한다.
그리고 [3, 4] 라는 새로운 객체를 더하고 이에 대한 id를 확인한다.
확인 결과는 id값이 같게 나온다. 또 다른 예제로 넘어가겠다.
"""

t = (1, 2)
print(id(t))
t += (3, 4)
print(id(t))
"""
3.
리스트에서는 아이디 값이 같게 나왔으나 튜플에서는 아이디 값이 다르게 나온다.
아이디 값이 다르게 나오는 것에 의문이 든다. 이에 대해서 조금 설명하자면 다음과 같다.
기존의 튜플 (1, 2) 객체는 t를 참조하며 레퍼런스 카운트는 1이었다. 하지만 튜플인 immutable한 객체이므로 수정이 불가능하다.
그런데 (3, 4) 라는 새로운 튜플 객체를 추가한다면 파이썬은 어떻게 동작하는 것일까?

id값에서 다른 것으로 유추하면 튜플 (1, 2)가 참조하던 t는 더 이상 (1, 2) 객체를 참조하지 않고 (1, 2, 3, 4) 라는 새로운 객체를 참조하게 되는 것이다.
앞서서 우리가 배운 레퍼런스 카운트로 생각해보면 (1, 2)는 t를 참조해 1이었으나 더 이상 참조하지 않기 때문에 0이 되어 소멸 대상이 되어버리는 것이다.

즉, 정리하면 mutable한 리스트와 같은 객체는 같은 변수를 참조하지만 immutable한 튜플같은 경우에는 더 이상 그 변수를 참조하지 않고 새로운 객체에 참조하게 되는 것이다.
이를 파이썬이 자동으로 처리해주기 때문에 우리는 이를 인식하지 못하지만 그 id 값을 찍어보면 다른 값이 나오기에 결과를 예상할 수 있다.
"""

def add_tuple(a, b):
    a += b
    print(a)

r1 = [1, 2]
print(id(r1))
add_tuple(r1, [3, 4])
print(r1)
print(id(r1))
"""
4.
함수를 통해서 mutable한 객체와 immutable한 객체의 차이를 알아보겠다.
먼저 mutable한 객체인 리스트의 경우이다. add_tuple 이라고 하는 함수를 하나 만들고 a에 b가 추가되도록 연산을 만들었다.
위의 print() 모듈을의 결과는 [1, 2, 3, 4] 객체가 나오게 된다. 여기서 id를 비교해보면 같다는 것을 알 수 있다.

여기서 조금 더 심화적으로 보자면 리스트 [1, 2] 객체는 r1이라는 변수를 참조한다. 따라서 레퍼런스 카운트는 1이다.
그리고 함수를 통해 r1이 a라는 파라미터를 참조하게 되므로 레퍼런스 카운트는 2가 된다.
이 때 함수 하단에 a를 출력해보면 리스트 객체들끼리 잘 합쳐져서 나온 값임을 알 수 있다. 이는 기존에 참조하던 변수에 더해졌다는 의미이다.
"""

t1 = (1, 2)
print(id(t1))
add_tuple(t1, (3, 4))
print(t1)
print(id(t1))
"""
5.
이번엔 튜플을 더해보겠다. 일단 결과적으로 더하고 나서 원래 값을 출력해도 제대로 된 값을 출력받지 못한다. 그 이유는 무엇일까?
튜플 (1, 2) 객체는 t1이라는 변수를 참조한다. 그리고 add_tuple 함수를 통해 (3, 4) 라는 새로운 객체를 더한다.
튜플은 immutable한 객체이고 위에서도 언급했지만 기존에 참조했던 객체가 아닌 새로운 객체를 변수가 참조하게 된다고 했다.
따라서 함수 내 로직에서는 (1, 2, 3, 4) 객체가 나오지만 이는 t1에 참조되어 있는 튜플 (1, 2)의 객체와는 다른 것이다.
따라서 t1 변수를 출력해도 우리가 생각했던 튜플 (1, 2, 3, 4)가 아닌 기존의 튜플 (1, 2) 객체를 얻게 되는 것이다.

즉, 함수를 통한 mutable한 객체와 immutable한 객체를 정리하면 다음과 같다.
r1 변수는 리스트 [1, 2]를 참조해서 레퍼런스 카운트는 1, 그리고 함수 내 로직으로 들어와 a라는 파라미터를 참조하므로 레퍼런스 카운트는 2이다.
t1 변수는 튜플 (1, 2)를 참조해서 레퍼런스 카운트는 1이지만 함수 내 로직으로 들어와서 a라는 파라미터를 참조해 또 다른 객체 b를 더하지만 레퍼런스 카운트는 1이다.
따라서 mutable한 객체는 전역 변수와 함수 내에서 참조하게 되는 파라미터가 같은 값을 의미하지만 immutable한 객체는 다른 값을 의미하게 되는 것이다.
"""

def add_tuple_update(a, b):
    a += b
    return a

t2 = (1, 2)
t2 = add_tuple_update(t2, (3, 4))
print(t2)
"""
6.
그렇다면 어떻게 해결해야할까?
immutable한 객체에서 문제점은 참조하는 것이 달라지는 것이었다. 따라서 참조하는 것을 맞춰주면 정상적으로 동작할 것이다.
먼저 함수 로직을 수정한다. 연산을 실행하고 새로 만들어진 튜플을 리턴시킨다.
그리고 함수 내 로직에서 반환된 파라미터를 해당 변수에 제대로 참조되도록 초기화시켜준다.
그렇다면 전역 변수로 가지고 있는 변수가 함수 내 로직을 수행해도 제대로 참조가 되어있기 때문에 알맞은 답을 출력할 수 있다.
"""

def max_min(array):
    array.sort()
    return array[0], array[-1]

l = [3, 1, 5, 4]
print(id(l))
print(max_min(l))
print(l)
print(id(l))
"""
7.
이번엔 다른 예제로 확인해보자. 정렬시키고 리스트 내 최댓값과 최솟값을 구하는 함수 로직이다.
함수 내에서 정렬을 시키고 전역 변수를 다시 print() 모듈을 실행해보면 어떨까?
결과는 정렬이 된 상태로 출력이 된다. 기존에 리스트 [3, 1, 5, 4] 객체는 l을 참조하고 함수 내 로직으로 들어와 array를 참조한다. 따라서 레퍼런스 카운트는 2이다.
동일한 변수의 객체가 수정되는 것이기 때문에 전역변수 l은 함수 내의 sort() 모듈로 인해 값이 변하게 된다.
"""

def max_min_update(array):
    new_array = list(array)
    new_array.sort()
    return new_array[0], new_array[-1]

l2 = [3, 1, 5, 4]
print(max_min_update(l2))
print(l2)
"""
8.
따라서 mutable한 객체는 수정이 가능한 객체이므로 위의 상황을 해결하기 위해서는 어떻게 해야할까?
정답은 새로운 변수에 리스트 객체를 참조시키는 것이다.
l2라는 변수가 리스트 [3, 1, 5, 4] 객체를 참조하므로 레퍼런스 카운트는 1이다.
함수 내 로직으로 l2의 객체가 array를 참조하지만 함수 내에서 new_array 라고 하는 새로운 변수를 참조시키기 때문에 레퍼런스 카운트는 2가 아닌 1이다.

함수 내 로직에서는 l2 변수가 아닌 이를 복사한 new_array로 로직을 만들어내기 때문에 l2의 값은 변하지 않게 된다.
"""